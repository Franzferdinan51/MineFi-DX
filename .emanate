"use strict";

const KASPA_DEFAULT_BRANCH = 'v0.7.1-dev';

const E = new Emanator(__dirname, {
    type : argv.build ? 'NODE+NWJS' : 'UTIL',
    guid : 'c1072045-6d98-44d8-9aa5-e9be6c79bd01',
    group : 'Kaspa',
    ident : 'kdx',
    title : 'KDX',
    banner : 'KDX',
    git : 'git@github.com:aspectron/kdx',
    author : "ASPECTRON Inc.",
    url : "http://aspectron.com",
    //archive : true,
    folder : true,
    standalone : true,
    production: true,
    //DMG: true,
    nwjs : { version : '0.48.2' },
    resources : 'resources/setup',

    manifest : (manifest) => {
        if(E.flags['with-perfmon'] && !E.flags['no-perfmon']) {
            if(E.PLATFORM != 'darwin') {
                Object.assign(manifest.dependencies,{
                    "@aspectron/process-list": "*",
                })
            }
        }

        if(E.PLATFORM == 'darwin')
            manifest.files.push('apps');

        return manifest;
    },
})

E.aux_dmg_files = async (root) => {
    await E.copy(path.join(E.BUILD,'apps'),path.join(root,'apps'));

    //    E.copy(process.argv[0], root);
}

const go = await E.modules.go('go1.14.3');
const git = await E.modules.git();
const gcc = await E.modules.gcc();
const npm = await E.modules.npm({ production : true });

if(E.flags.full || E.flags.all) {
    E.flags['with-dagviz'] = true;
    E.flags['with-kmetrics'] = true;
    E.flags['with-perfmon'] = true;
    E.flags['with-extras'] = true;
}

E.flags['with-dagviz'] && E.task('dagviz', ['remote'], async () => {
    const dest = path.join(E.BUILD,'apps');
    mkdirp.sync(dest);

    const dagvizFolder = path.join(dest,'dagviz');
    await E.remove(dagvizFolder);
    await git.clone('git@github.com:kaspanet/dagviz', dest, { branch : E.flags['dagviz-branch'] || 'master' });
    await E.remove(path.join(dagvizFolder,'.git'));
    await npm.install({ cwd : dagvizFolder});
    //await E.spawn('emanate', ['--local-binaries'], { cwd : dagvizFolder, stdio: 'inherit' });
    
    execSync('emanate --local-binaries', { cwd : dagvizFolder, stdio : 'inherit' });    
    await E.copy(process.argv[0],path.join(dagvizFolder,path.basename(process.argv[0])));
    //await E.spawn('emanate', ['--local-binaries'], { cwd : dagvizFolder, stdio: 'inherit' });

    // sine dagviz carries a lot of modules already included with kdx
    // scan for duplicates and remove them from dagviz as require() will
    // scan parent folders (kdx) for node_module
    // --- this doesn't work properly - breaks dependency resolution in the deployment
    // let dagvizModules = fs.readdirSync(path.join(dagvizFolder,'node_modules'));
    // let kdxModules = fs.readdirSync(path.join(E.BUILD,'node_modules'));
    // let duplicates = dagvizModules.filter(f => kdxModules.includes(f) && !/^\.\.?$/.test(f));
    // let jobs = duplicates.map(f => E.remove(path.join(dagvizFolder,'node_modules',f)));
    // await Promise.all(jobs);
});

/*
E.flags['with-ksandbox'] && E.task('ksandbox', ['remote'], async () => {
    const dest = path.join(E.BUILD,'apps')
    mkdirp.sync(dest);
    const ksandboxFolder = path.join(dest,'ksandbox');
    return Promise.resolve();
});
*/

E.flags['with-kmetrics'] && E.task('kmetrics', ['remote'], async () => {
    const dest = path.join(E.BUILD,'apps')
    mkdirp.sync(dest);
    const kmetricsFolder = path.join(dest,'kmetrics');
    await E.remove(kmetricsFolder);
    await git.clone('git@github.com:kaspanet/kmetrics', dest, { branch : E.flags['kmetrics-branch'] || 'master' });
    await E.remove(path.join(kmetricsFolder,'.git'));

    return Promise.resolve();
});

const kaspad = E.task('kaspad', ['origin'], async () => {

    //return true;
    if(E.PLATFORM == 'windows') {
        process.env.PATH = ['C:\\TDM-GCC-64\\bin', ...process.env.PATH.split(';')].join(';');
    }

    let dest = path.join(go.SRC,'github.com/kaspanet/');
    if((E.flags.reset || E.flags.clean) && fs.existsSync(dest))
        await E.emptyDir(dest);

    const branch = E.flags['branch'] || KASPA_DEFAULT_BRANCH || 'master';
    
    console.log('branch:',branch);
    
    //const repos = { };
    const repos = [`kaspad:${branch}`,`kasparov:${branch}`];
    if(E.flags['with-extras']) {
        repos.push('miningsimulator');
        repos.push(`txgen:${branch}`);
    }

    console.log("REPOS:".brightMagenta,repos);

    for(const repo of repos) {
        let [name, git_branch] = repo.split(':');
        console.log(`git clone git@github.com:kaspanet/${name} branch: ${git_branch || 'master'}`.brightYellow);
        await git.clone(`git@github.com:kaspanet/${name}`,dest, {branch : git_branch || 'master'});
    }
    
    //     repos.extras = ['miningsimulator', `txgen:${branch}`];
    //     for(const repo of repos.extras) {
    //         const [name_, branch_] = repo.split(':');
    //         console.log(`git clone git@github.com:kaspanet/${name_}`);
    //         await git.clone(`git@github.com:kaspanet/${name}`,dest,{branch});
    //     }
    // }
        
    // ---

    let targets = [
        'kaspad',
        'kasparov/kasparovd',
        'kasparov/kasparovsyncd',
        'kasparov/examples/wallet',
        ...fs.readdirSync(path.join(dest,'kaspad/cmd')).map(f => `kaspad/cmd/${f}`),
    ];

    if(E.flags['with-extras']) {
        targets = [
            ...targets,
            // 'miningsimulator',
            'txgen',
        ];
    }

    let rename = {
    }
    console.log('Starting target processing...')
    //let jobs = []
    let folders = []

    for(let target of targets) {
        let folder = path.join(dest,target);
        console.log('builing',folder);
        await go.build(folder);
        console.log('done',folder);
        folders.push(folder);
        //jobs.push(go.build(folder));
    }
    //console.log('done - 1');
    //await Promise.all(jobs);

    folders.forEach((folder) => {
        let file = path.basename(folder);
        let name = `${E.title} ${file}`;
        let dest = rename[file] || file;
        file += E.PLATFORM_BINARY_EXTENSION;
        dest += E.PLATFORM_BINARY_EXTENSION;

        if(!fs.existsSync(path.join(folder,file))) {
            console.log(`Unable to locate source file: ${path.join(folder,file)}`);
            console.log(`...giving up`);
            process.exit(1);
        }

        E.copy(path.join(folder,file),path.join(E.BIN,dest));
        E.registerFirewallRule({ name, file : dest, binary : true });
    })

    E.copy(path.join(dest,'kasparov','database','migrations'),path.join(E.BIN,'database','migrations'));
});

const pgsql = E.task('pgsql', ['origin'], async () => {
    console.log("PGSQL",E.BIN)
    if(E.PLATFORM == 'linux')
        return Promise.resolve();

    if(E.flags.nodb || E.flags.nosql || E.flags.nopgsql)
        return Promise.resolve();

    const pgsql_url = {
        windows : { 
            url : 'http://sbp.enterprisedb.com/getfile.jsp?fileid=12454', 
            file : `postgresql-12.2-2-windows-x64-binaries.zip` 
        },
        darwin : { 
            url : 'https://sbp.enterprisedb.com/getfile.jsp?fileid=12475', 
            file : `postgresql-12.2-3-osx-binaries.zip` 
        }
    }[E.PLATFORM];
    // `postgresql-12.2-3-osx-binaries.zip`.match(/^\w+-(\d).(\d)-(\d)/)
    const [, major, minor, release_] = pgsql_url.file.match(/^\w+-(\d+).(\d+)-(\d+)/);
    const version = `${major}.${minor}.${release_}`;

    E.utils.resetTTY();

    const file = path.join(E.DEPS,pgsql_url.file);
    const basename = path.basename(pgsql_url.file).replace(/\.(zip|tar|tar.gz|tar.xz)$/,'');
    const archiveFolder = path.join(E.DEPS, basename);
    if(!fs.existsSync(file) || !fs.existsSync(path.join(archiveFolder,'pgsql'))) {
        await E.download(pgsql_url.url,file);
        await E.unzip(file, archiveFolder);
    }

    const targetBinFolder = path.join(E.BIN,basename);
    if(fs.existsSync(targetBinFolder)) {
        E.log(`WARNING: previous pgSQL deployment found...`.brightRed,);
        E.log(`         cleaning up existing ${targetBinFolder}...`);
        await fs.remove(targetBinFolder);
    }
    mkdirp.sync(targetBinFolder);

    E.log(`copying ${basename}...`);
    let folders = ['bin','lib','share'];

    // --pgsql-full-distro adds 425 Mb to the final distribution :/
    if(E.flags['pgsql-full-distro'])
        folders.push('pgadmin 4', 'stackbuilder', 'symbols', 'include', 'doc');
    
    const jobs = folders.map((f) => {
        if(E.PLATFORM == 'windows') {
            return E.copy(path.join(archiveFolder,'pgsql',f), path.join(targetBinFolder,f));
        }
        else
            return E.spawn('cp', ['-R',path.join(archiveFolder,'pgsql',f),path.join(targetBinFolder,f)], { cwd : E.DEPS, stdio: 'inherit' });
    })
    await Promise.all(jobs);

    [ 'postgres', 'pg_ctl', 'psql', 'initdb' ].forEach((f) => {
        let name = `KDX pgSQL ${f}`;
        let file = path.join(basename, 'bin', f+E.PLATFORM_BINARY_EXTENSION);
        E.registerFirewallRule({ name, file, binary : true });
    })

    E.log('done...');
});

E.task('remote', ['origin'], async () => {


    // let files = E.manifest.files.slice();
    // while(files.length) {
    //     let f = files.shift();
    //     console.log('copying:',f);
    //     await E.copy(path.join(E.REPO,f), path.join(E.BUILD, f));
    // }

    // console.log('done');

    let files = (E.manifest.files||[]).map(f=>{
        // console.log(E.REPO,'->',E.BUILD, f);
        return E.copy(path.join(E.REPO,f), path.join(E.BUILD, f));
    })
    E.log(`copying ${files.length} items...`);
    await Promise.all(files);

    fs.writeFileSync(path.join(E.BUILD,'i18n.lock'),'');
    console.log(`i18n.lock`);
})

E.task('mqtt',['origin'], async () => {
    E.log('setting up mqtt...');
    if(E.PLATFORM == 'windows') {
        E.registerFirewallRule({ name : 'KDX MQTT', file : 'mosquitto/mosquitto.exe', binary : true });
        return E.copy(path.join(E.REPO,'resources','deps','mosquitto-windows-x64'),path.join(E.BIN,'mosquitto'));
    } else if(E.PLATFORM == 'darwin') {

        E.log('cleaning up bin/brew');
        await E.remove(path.join(E.BIN,'brew'));
        const brew = `/usr/local/Cellar/`;
        let folders = ['libevent','libuv','libwebsockets','openssl@1.1','mosquitto'];
        while(folders.length) {
            let f = folders.shift();
            let folder = path.join(brew,f);
            E.log(`brew - copying ${f}`);
            let versions = fs.readdirSync(folder);
            while(versions.length) {
                let v = versions.shift();
                let srcver = path.join(folder,v);
                const list = ['AUTHORS','LICENSE','README.md','notice.html','README','bin','lib','sbin'];
                while(list.length) {
                    let t = list.shift();
                    let src = path.join(srcver,t);
                    if(fs.existsSync(src)) {
                        let dest = path.join(E.BIN,'brew',f,v,t);
                        E.log('+--<'+src);
                        E.log('+-->'+dest);
                        await E.copy(src,dest);
                    }
                }
            }

            // await E.copy(folder,path.join(E.BIN,'brew',f));
            
        }
        return Promise.resolve();
//        return E.copy(path.join(E.REPO,'resources','deps','mosquitto-darwin-x64'),path.join(E.BIN,'mosquitto'));
    }
})

E.task('done', ['pgsql','kaspad','remote','mqtt'], async () => {

})

E.task('aptitude', null, async () => {
    if(E.PLATFORM != 'linux')
        return;
})

E.flags.docker && E.task('docker', null, async () => {

    E.manifest_read();

    const relay = ['no-cache'];
    const args = ['-s','docker','build'].concat(relay.map(k=>E.flags[k]?`--${k}`:null)).filter(v=>v);
    args.push('-t',`kdx:latest`,'.');
    const ts0 = Date.now();
    await E.utils.spawn('sudo', args, { cwd : __dirname, stdio: 'inherit' });
    await E.utils.spawn('sudo',['docker','tag','kdx:latest',`kdx:${E.manifest.version}`], { cwd : __dirname, stdio: 'inherit' });
    console.log('Docker build complete at',new Date());
    const ts1 = Date.now();
    console.log('Docker build took'.brightBlue,`${((ts1-ts0)/1000/60).toFixed(1)}`.brightWhite,'minutes'.brightBlue)
});


if(E.flags['local-binaries'] || E.flags['pgsql'] || E.flags['mqtt'] || E.flags['kaspa']) {
    E.BIN = path.join(E.appFolder,'bin',E.PLATFORM_ARCH);
    mkdirp.sync(E.BIN);
}


if(E.flags.link) {
    let list = ['flow-ux','flow-app','flow-utils','flow-rpc','flow-async'];
    while(list.length) {
        let ident = list.shift();
        await npm.link(`@aspectron/${ident}`, { cwd : __dirname, stdio : 'inherit' });
    }
}
else 
if(E.flags.docker) {
    E.runTask('docker');
}
else if(E.flags['pgsql']) 
    //E.run(['pgsql']);
    await pgsql();
else if(E.flags['mqtt']) 
    E.run(['mqtt']);
else if(E.flags['kaspa']) 
    await kaspad();
    //E.run(['kaspad']);
else if(E.flags['local-binaries']) {
    E.runTask('kaspad');
    E.runTask('pgsql');
    E.runTask('mqtt');
    E.runTask('aptitude');
//    E.run(['kaspad','pgsql', 'mqtt', 'aptitude']);
}
else
    E.run();
